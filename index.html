<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV Interdimensionale</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="tv-container">
        <div class="tv-frame">
            <div class="screen">
                <div class="scanlines"></div>
                <div class="glitch-effect"></div>
                <div id="player"></div>
            </div>
            <div class="channel-info">WAITING FOR SIGNAL...</div>
            <div class="rec-status">
                <span class="rec-dot">REC</span>
                <span class="rec-timer">00:00:00</span>
            </div>
        </div>
        <div class="controls">
            <button id="prevChannel" disabled>Channel -</button>
            <div class="spotify-section">
                <button onclick="handleLogin()" class="spotify-button">
                    <span class="spotify-icon">ðŸŽµ</span> Connect with Spotify
                </button>
                <div id="playlistSection" class="hidden">
                    <select id="playlistSelect">
                        <option value="">Select a playlist...</option>
                    </select>
                    <button id="loadButton">Load Playlist</button>
                </div>
            </div>
            <button id="nextChannel" disabled>Channel +</button>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // Debug logging
        function log(message, data = null) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage, data);
            updateChannelInfo(message);
        }

        function updateChannelInfo(text) {
            document.querySelector('.channel-info').textContent = text;
        }

        // Spotify configuration
        const clientId = '7a82dcab533b4f3c8d440bb23f82c6b6';
        const clientSecret = '9cf7d438efd74c3a8ec1875dc47c22b4';
        const redirectUri = window.location.origin;

        // Handle login
        function handleLogin() {
            try {
                log('Initiating Spotify login...');
                // Generate random state
                const state = Math.random().toString(36).substring(2, 15);
                localStorage.setItem('spotify_auth_state', state);
                
                const params = new URLSearchParams({
                    client_id: clientId,
                    response_type: 'code',
                    redirect_uri: redirectUri,
                    state: state,
                    scope: 'playlist-read-private playlist-read-collaborative',
                    show_dialog: true
                });

                const authUrl = `https://accounts.spotify.com/authorize?${params.toString()}`;
                log('Generated auth URL:', authUrl);
                window.location.href = authUrl;
            } catch (error) {
                log('Login error:', error.message);
                console.error('Login error:', error);
            }
        }

        // Check for auth callback
        window.addEventListener('load', () => {
            log('Checking for auth callback...');
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');
            const storedState = localStorage.getItem('spotify_auth_state');

            if (error) {
                log('Authentication error:', error);
                return;
            }

            if (code) {
                log('Found authorization code');
                if (state === null || state !== storedState) {
                    log('State mismatch, possible CSRF attack');
                    return;
                }

                // Clear state
                localStorage.removeItem('spotify_auth_state');

                // Exchange code for token
                exchangeCodeForToken(code);
            } else {
                log('No code found, checking for stored token');
                if (localStorage.getItem('spotify_token')) {
                    handleAuthentication();
                }
            }
        });

        async function exchangeCodeForToken(code) {
            try {
                log('Exchanging code for token...');
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)
                    },
                    body: new URLSearchParams({
                        grant_type: 'authorization_code',
                        code: code,
                        redirect_uri: redirectUri
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                log('Got access token');
                localStorage.setItem('spotify_token', data.access_token);
                localStorage.setItem('spotify_token_expiry', Date.now() + (data.expires_in * 1000));
                if (data.refresh_token) {
                    localStorage.setItem('spotify_refresh_token', data.refresh_token);
                }
                handleAuthentication();
            } catch (error) {
                log('Token exchange error:', error.message);
                console.error('Token exchange error:', error);
            }
        }

        async function refreshToken() {
            try {
                log('Refreshing token...');
                const refresh_token = localStorage.getItem('spotify_refresh_token');
                if (!refresh_token) {
                    throw new Error('No refresh token available');
                }

                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: refresh_token
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                log('Token refreshed successfully');
                localStorage.setItem('spotify_token', data.access_token);
                localStorage.setItem('spotify_token_expiry', Date.now() + (data.expires_in * 1000));
                if (data.refresh_token) {
                    localStorage.setItem('spotify_refresh_token', data.refresh_token);
                }
                return data.access_token;
            } catch (error) {
                log('Token refresh error:', error.message);
                console.error('Token refresh error:', error);
                // If refresh fails, clear all tokens and redirect to login
                localStorage.removeItem('spotify_token');
                localStorage.removeItem('spotify_refresh_token');
                localStorage.removeItem('spotify_token_expiry');
                window.location.href = window.location.origin;
                throw error;
            }
        }

        async function getValidToken() {
            const token = localStorage.getItem('spotify_token');
            const expiry = localStorage.getItem('spotify_token_expiry');
            
            if (!token || !expiry) {
                throw new Error('No token available');
            }

            // If token expires in less than 5 minutes, refresh it
            if (Date.now() > (parseInt(expiry) - 300000)) {
                return await refreshToken();
            }

            return token;
        }

        async function handleAuthentication() {
            try {
                log('Handling authentication...');
                document.querySelector('.spotify-button').style.display = 'none';
                document.getElementById('playlistSection').classList.remove('hidden');
                await loadPlaylists();
            } catch (error) {
                log('Authentication handling error:', error.message);
                console.error('Auth handling error:', error);
            }
        }

        async function loadPlaylists() {
            try {
                log('Loading playlists...');
                const token = await getValidToken();

                const response = await fetch('https://api.spotify.com/v1/me/playlists', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                log('Loaded playlists:', { count: data.items.length });

                const select = document.getElementById('playlistSelect');
                select.innerHTML = '<option value="">Select a playlist...</option>';
                data.items.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.id;
                    option.textContent = playlist.name;
                    select.appendChild(option);
                });
            } catch (error) {
                log('Error loading playlists:', error.message);
                console.error('Playlist loading error:', error);
                if (error.message.includes('No token available')) {
                    handleLogin();
                }
            }
        }

        let currentPlaylist = [];
        let currentTrackIndex = 0;

        document.getElementById('loadButton').addEventListener('click', loadSelectedPlaylist);
        document.getElementById('prevChannel').addEventListener('click', playPreviousTrack);
        document.getElementById('nextChannel').addEventListener('click', playNextTrack);

        async function loadSelectedPlaylist() {
            try {
                const playlistId = document.getElementById('playlistSelect').value;
                if (!playlistId) {
                    log('No playlist selected');
                    return;
                }

                log('Loading selected playlist:', playlistId);
                const token = await getValidToken();
                const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                currentPlaylist = data.items.map(item => ({
                    title: item.track.name,
                    artist: item.track.artists[0].name
                }));

                log('Playlist loaded:', { trackCount: currentPlaylist.length });
                currentTrackIndex = 0;
                document.getElementById('prevChannel').disabled = false;
                document.getElementById('nextChannel').disabled = false;
                await playCurrentTrack();
            } catch (error) {
                log('Error loading playlist:', error.message);
                console.error('Playlist loading error:', error);
                if (error.message.includes('No token available')) {
                    handleLogin();
                }
            }
        }

        let youtubePlayer;
        function onYouTubeIframeAPIReady() {
            log('YouTube API ready');
            youtubePlayer = new YT.Player('player', {
                height: '100%',
                width: '100%',
                videoId: '',
                playerVars: {
                    autoplay: 1,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onError: onPlayerError,
                    onStateChange: onPlayerStateChange
                }
            });
        }

        async function searchYouTubeVideo(title, artist) {
            try {
                log('Searching YouTube video:', { title, artist });
                const query = encodeURIComponent(`${title} ${artist} official music video`);
                const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=id&type=video&q=${query}&key=YOUR_YOUTUBE_API_KEY`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const videoId = data.items[0]?.id?.videoId;
                log('Found video:', { videoId });
                return videoId;
            } catch (error) {
                log('YouTube search error:', error.message);
                console.error('YouTube search error:', error);
                return null;
            }
        }

        async function playCurrentTrack() {
            try {
                const track = currentPlaylist[currentTrackIndex];
                if (!track) {
                    log('No track to play');
                    return;
                }

                log('Playing track:', track);
                updateChannelInfo(`CHANNEL ${currentTrackIndex + 1} - ${track.title}`);
                showGlitchEffect();

                const videoId = await searchYouTubeVideo(track.title, track.artist);
                if (videoId) {
                    youtubePlayer.loadVideoById(videoId);
                } else {
                    updateChannelInfo('VIDEO NOT FOUND');
                }
            } catch (error) {
                log('Error playing track:', error.message);
                console.error('Playback error:', error);
                updateChannelInfo('PLAYBACK ERROR');
            }
        }

        function playPreviousTrack() {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
                playCurrentTrack();
            }
        }

        function playNextTrack() {
            if (currentTrackIndex < currentPlaylist.length - 1) {
                currentTrackIndex++;
                playCurrentTrack();
            }
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                playNextTrack();
            }
        }

        function onPlayerError(event) {
            log('YouTube player error:', event.data);
            updateChannelInfo('VIDEO PLAYBACK ERROR');
            setTimeout(playNextTrack, 3000);
        }

        function showGlitchEffect() {
            const glitch = document.querySelector('.glitch-effect');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 300);
        }

        // Timer
        let recordingTime = 0;
        const recTimer = document.querySelector('.rec-timer');
        setInterval(() => {
            recordingTime++;
            const hours = Math.floor(recordingTime / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((recordingTime % 3600) / 60).toString().padStart(2, '0');
            const seconds = (recordingTime % 60).toString().padStart(2, '0');
            recTimer.textContent = `${hours}:${minutes}:${seconds}`;
        }, 1000);
    </script>
</body>
</html> 