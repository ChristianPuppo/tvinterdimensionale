<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV Interdimensionale</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="tv-container">
        <div class="tv-frame">
            <div class="screen">
                <div class="scanlines"></div>
                <div class="glitch-effect"></div>
                <div id="player"></div>
            </div>
            <div class="channel-info">WAITING FOR SIGNAL...</div>
            <div class="rec-status">
                <span class="rec-dot">REC</span>
                <span class="rec-timer">00:00:00</span>
            </div>
        </div>
        <div class="controls">
            <button id="prevChannel" disabled>Channel -</button>
            <div class="spotify-section">
                <button onclick="handleLogin()" class="spotify-button">
                    <span class="spotify-icon">ðŸŽµ</span> Connect with Spotify
                </button>
                <div id="playlistSection" class="hidden">
                    <select id="playlistSelect">
                        <option value="">Select a playlist...</option>
                    </select>
                    <button id="loadButton">Load Playlist</button>
                </div>
            </div>
            <button id="nextChannel" disabled>Channel +</button>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // Debug logging
        function log(message, data = null) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage, data);
            updateChannelInfo(message);
        }

        function updateChannelInfo(text) {
            document.querySelector('.channel-info').textContent = text;
        }

        // Spotify configuration
        const clientId = '7a82dcab533b4f3c8d440bb23f82c6b6';
        const redirectUri = window.location.origin;

        // Handle login
        function handleLogin() {
            try {
                log('Initiating Spotify login...');
                const params = new URLSearchParams({
                    client_id: clientId,
                    response_type: 'token',
                    redirect_uri: redirectUri,
                    scope: 'playlist-read-private playlist-read-collaborative',
                    show_dialog: true
                });

                const authUrl = `https://accounts.spotify.com/authorize?${params.toString()}`;
                log('Generated auth URL:', authUrl);
                window.location.href = authUrl;
            } catch (error) {
                log('Login error:', error.message);
                console.error('Login error:', error);
            }
        }

        // Check for auth callback
        window.addEventListener('load', () => {
            log('Checking for auth callback...');
            const hash = window.location.hash;
            if (hash) {
                log('Found hash in URL:', hash);
                try {
                    const params = new URLSearchParams(hash.substring(1));
                    const accessToken = params.get('access_token');
                    const error = params.get('error');

                    if (error) {
                        throw new Error(`Authentication error: ${error}`);
                    }

                    if (accessToken) {
                        log('Got access token');
                        localStorage.setItem('spotify_token', accessToken);
                        window.location.hash = '';
                        handleAuthentication();
                    } else {
                        log('No access token found in hash');
                    }
                } catch (error) {
                    log('Error parsing hash:', error.message);
                    console.error('Hash parsing error:', error);
                }
            } else {
                log('No hash found, checking for stored token');
                if (localStorage.getItem('spotify_token')) {
                    handleAuthentication();
                }
            }
        });

        async function handleAuthentication() {
            try {
                log('Handling authentication...');
                document.querySelector('.spotify-button').style.display = 'none';
                document.getElementById('playlistSection').classList.remove('hidden');
                await loadPlaylists();
            } catch (error) {
                log('Authentication handling error:', error.message);
                console.error('Auth handling error:', error);
            }
        }

        async function loadPlaylists() {
            try {
                log('Loading playlists...');
                const token = localStorage.getItem('spotify_token');
                if (!token) {
                    throw new Error('No token found');
                }

                const response = await fetch('https://api.spotify.com/v1/me/playlists', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                log('Loaded playlists:', { count: data.items.length });

                const select = document.getElementById('playlistSelect');
                select.innerHTML = '<option value="">Select a playlist...</option>';
                data.items.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.id;
                    option.textContent = playlist.name;
                    select.appendChild(option);
                });
            } catch (error) {
                log('Error loading playlists:', error.message);
                console.error('Playlist loading error:', error);
                localStorage.removeItem('spotify_token');
                window.location.reload();
            }
        }

        let currentPlaylist = [];
        let currentTrackIndex = 0;

        document.getElementById('loadButton').addEventListener('click', loadSelectedPlaylist);
        document.getElementById('prevChannel').addEventListener('click', playPreviousTrack);
        document.getElementById('nextChannel').addEventListener('click', playNextTrack);

        async function loadSelectedPlaylist() {
            try {
                const playlistId = document.getElementById('playlistSelect').value;
                if (!playlistId) {
                    log('No playlist selected');
                    return;
                }

                log('Loading selected playlist:', playlistId);
                const token = localStorage.getItem('spotify_token');
                const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                currentPlaylist = data.items.map(item => ({
                    title: item.track.name,
                    artist: item.track.artists[0].name
                }));

                log('Playlist loaded:', { trackCount: currentPlaylist.length });
                currentTrackIndex = 0;
                document.getElementById('prevChannel').disabled = false;
                document.getElementById('nextChannel').disabled = false;
                await playCurrentTrack();
            } catch (error) {
                log('Error loading playlist:', error.message);
                console.error('Playlist loading error:', error);
            }
        }

        let youtubePlayer;
        function onYouTubeIframeAPIReady() {
            log('YouTube API ready');
            youtubePlayer = new YT.Player('player', {
                height: '100%',
                width: '100%',
                videoId: '',
                playerVars: {
                    autoplay: 1,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onError: onPlayerError,
                    onStateChange: onPlayerStateChange
                }
            });
        }

        async function searchYouTubeVideo(title, artist) {
            try {
                log('Searching YouTube video:', { title, artist });
                const query = encodeURIComponent(`${title} ${artist} official music video`);
                const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=id&type=video&q=${query}&key=YOUR_YOUTUBE_API_KEY`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const videoId = data.items[0]?.id?.videoId;
                log('Found video:', { videoId });
                return videoId;
            } catch (error) {
                log('YouTube search error:', error.message);
                console.error('YouTube search error:', error);
                return null;
            }
        }

        async function playCurrentTrack() {
            try {
                const track = currentPlaylist[currentTrackIndex];
                if (!track) {
                    log('No track to play');
                    return;
                }

                log('Playing track:', track);
                updateChannelInfo(`CHANNEL ${currentTrackIndex + 1} - ${track.title}`);
                showGlitchEffect();

                const videoId = await searchYouTubeVideo(track.title, track.artist);
                if (videoId) {
                    youtubePlayer.loadVideoById(videoId);
                } else {
                    updateChannelInfo('VIDEO NOT FOUND');
                }
            } catch (error) {
                log('Error playing track:', error.message);
                console.error('Playback error:', error);
                updateChannelInfo('PLAYBACK ERROR');
            }
        }

        function playPreviousTrack() {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
                playCurrentTrack();
            }
        }

        function playNextTrack() {
            if (currentTrackIndex < currentPlaylist.length - 1) {
                currentTrackIndex++;
                playCurrentTrack();
            }
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                playNextTrack();
            }
        }

        function onPlayerError(event) {
            log('YouTube player error:', event.data);
            updateChannelInfo('VIDEO PLAYBACK ERROR');
            setTimeout(playNextTrack, 3000);
        }

        function showGlitchEffect() {
            const glitch = document.querySelector('.glitch-effect');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 300);
        }

        // Timer
        let recordingTime = 0;
        const recTimer = document.querySelector('.rec-timer');
        setInterval(() => {
            recordingTime++;
            const hours = Math.floor(recordingTime / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((recordingTime % 3600) / 60).toString().padStart(2, '0');
            const seconds = (recordingTime % 60).toString().padStart(2, '0');
            recTimer.textContent = `${hours}:${minutes}:${seconds}`;
        }, 1000);
    </script>
</body>
</html> 